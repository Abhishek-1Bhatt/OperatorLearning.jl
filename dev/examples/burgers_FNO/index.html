<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Burgers Equation with FNO · OperatorLearning.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://pzimbrod.github.io/OperatorLearning.jl/examples/burgers_FNO/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="OperatorLearning.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OperatorLearning.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Burgers Equation with FNO</a></li><li><a class="tocitem" href="../burgers_DeepONet/">Burgers Equation with DeepONet</a></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../reference/">Module Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Burgers Equation with FNO</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Burgers Equation with FNO</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pzimbrod/OperatorLearning.jl/blob/master/docs/src/examples/burgers_FNO.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solving-the-Burgers-Equation-with-the-Fourier-Neural-Operator"><a class="docs-heading-anchor" href="#Solving-the-Burgers-Equation-with-the-Fourier-Neural-Operator">Solving the Burgers Equation with the Fourier Neural Operator</a><a id="Solving-the-Burgers-Equation-with-the-Fourier-Neural-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-Burgers-Equation-with-the-Fourier-Neural-Operator" title="Permalink"></a></h1><p>This example mostly replicates the original work by <a href="https://github.com/zongyi-li/fourier_neural_operator/blob/master/fourier_1d.py">Li et al</a>.</p><p>We try to create an operator for the Burgers equation</p><p class="math-container">\[\partial_t u(x,t) + \partial_x (u^2(x,t)/2) = \nu \partial_{xx} u(x,t)\]</p><p>in one dimension for a unit spacial and temporal domain. The operator maps the initial condition <span>$u(x,0) = u_0(x)$</span> to the flow field at the final time <span>$u(x,1)$</span>.</p><p>So overall, we need an approximation function that does the following:</p><pre><code class="language-julia hljs">function foo(u0,x)
    # Do something
    return u1</code></pre><p>We sample from a dataset that contains several instances of the initial condition (<code>a</code>) and the final velocity field (<code>u</code>). The data is given on a grid of 8192 points, however we would like to only sample 1024 points.</p><pre><code class="language-julia hljs">using Flux: length, reshape, train!, throttle, @epochs
using OperatorLearning, Flux, MAT

device = gpu;

# Read the data from MAT file and store it in a dict
vars = matread(&quot;burgers_data_R10.mat&quot;) |&gt; device

# For trial purposes, we might want to train with different resolutions
# So we sample only every n-th element
subsample = 2^3;

# create the x training array, according to our desired grid size
xtrain = vars[&quot;a&quot;][1:1000, 1:subsample:end] |&gt; device;
# create the x test array
xtest = vars[&quot;a&quot;][end-99:end, 1:subsample:end] |&gt; device;

# Create the y training array
ytrain = vars[&quot;u&quot;][1:1000, 1:subsample:end] |&gt; device;
# Create the y test array
ytest = vars[&quot;u&quot;][end-99:end, 1:subsample:end] |&gt; device;</code></pre><p>For now, we only have one input and one output array. In addition, we need corresponding x values for a(x) and u(x) as the second input array which at this point are still missing. The data were sampled from an equispaced grid (otherwise the FFT in our architecture wouldn&#39;t work anyway), so manually creating them is fairly straightforward:</p><pre><code class="language-julia hljs"># The data is missing grid data, so we create it
# `collect` converts data type `range` into an array
grid = collect(range(0, 1, length=length(xtrain[1,:]))) |&gt; device

# Merge the created grid with the data
# Output has the dims: batch x grid points x 2  (a(x), x)
# First, reshape the data to a 3D tensor,
# Then, create a 3D tensor from the synthetic grid data
# and concatenate them along the newly created 3rd dim
xtrain = cat(reshape(xtrain,(1000,1024,1)),
            reshape(repeat(grid,1000),(1000,1024,1));
            dims=3) |&gt; device
ytrain = cat(reshape(ytrain,(1000,1024,1)),
            reshape(repeat(grid,1000),(1000,1024,1));
            dims=3) |&gt; device
# Same treatment with the test data
xtest = cat(reshape(xtest,(100,1024,1)),
            reshape(repeat(grid,100),(100,1024,1));
            dims=3) |&gt; device
ytest = cat(reshape(ytest,(100,1024,1)),
            reshape(repeat(grid,100),(100,1024,1));
            dims=3) |&gt; device</code></pre><p>Next we need to consider the shape that the <code>FourierLayer</code> expects the inputs to be, i.e. <code>[numInputs, grid, batch]</code>. But our dataset contains the batching dim as the first one, so we need to do some permuting:</p><pre><code class="language-julia hljs"># Our net wants the input in the form (2,grid,batch), though,
# So we permute
xtrain, xtest = permutedims(xtrain,(3,2,1)), permutedims(xtest,(3,2,1)) |&gt; device
ytrain, ytest = permutedims(ytrain,(3,2,1)), permutedims(ytest,(3,2,1)) |&gt; device</code></pre><p>In order to slice the data into mini-batches, we pass the arrays to the Flux <code>DataLoader</code>.</p><pre><code class="language-julia hljs"># Pass the data to the Flux DataLoader and give it a batch of 20
train_loader = Flux.Data.DataLoader((xtrain, ytrain), batchsize=20, shuffle=true) |&gt; device
test_loader = Flux.Data.DataLoader((xtest, ytest), batchsize=20, shuffle=false) |&gt; device</code></pre><p>We can now set up the architecture. We lift the inputs to a higher-dimensional space via a simple linear transform using a <code>Dense</code> layer. The input dimensionality is 2, we will transform it to 128. After that, we set up 4 instances of a Fourier Layer where we keep only 16 of the <code>N/2 + 1 = 513</code> modes that the FFT provides and use the GeLU activation. Finally, we reduce the latent space to the two output arrays we wish to obtain - <code>u1(x)</code> and <code>x</code>:</p><pre><code class="language-julia hljs"># Set up the Fourier Layer
# 128 in- and outputs, batch size 20 as given above, grid size 1024
# 16 modes to keep, σ activation on the gpu
layer = FourierLayer(128,128,1024,16,gelu,bias_fourier=false) |&gt; device

# The whole architecture
# linear transform into the latent space, 4 Fourier Layers,
# then transform it back
model = Chain(Dense(2,128;bias=false), layer, layer, layer, layer,
                Dense(128,2;bias=false)) |&gt; device</code></pre><p>The rest is more or less boilerplate training code for a DNN. We employ the ADAM optimizer with a fixed learning rate of 1e-3, use the mean squared error as loss, evaluate the test loss as callback and train the FNO for 500 epochs.</p><pre><code class="language-julia hljs"># We use the ADAM optimizer for training
learning_rate = 0.001
opt = ADAM(learning_rate)

# Specify the model parameters
parameters = params(model)

# The loss function
loss(x,y) = Flux.Losses.mse(model(x),y)

# Define a callback function that gives some output during training
evalcb() = @show(loss(xtest,ytest))
# Print the callback only every 5 seconds, 
throttled_cb = throttle(evalcb, 5)

# Do the training loop
Flux.@epochs 500 train!(loss, parameters, train_loader, opt, cb = throttled_cb)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../burgers_DeepONet/">Burgers Equation with DeepONet »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Wednesday 9 February 2022 10:11">Wednesday 9 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
